/* Проект создан при помощи просмотра видео на канале "Фрилансер по жизни"
Ссылка на видео: https://youtu.be/f-irDQwt1l4 */

*,
*::before,
*::after {
  padding: 0;
  margin: 0;
  border: 0;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  /* Первая * означает "применить ко всем". Кроме того, отдельные * необходимы для применения к псевдоэлементам (здесь: ::before, ::after). По умолчанию, при обращении через * псевдоэлементы не учитываются */
}

a {
  text-decoration: none;
  /* Убираем подчёркёвание для всех ссылок */
}

ul,
ol,
li {
  list-style: none;
}

img {
  vertical-align: top;
  /* Применяется выравнивание по вертикали со значением "top" (применяется к тексту, в данном случае - внутри картинки), т.е. всегда распологается сверху */
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: inherit;
  font-size: inherit;
  /* Данные блоки будут наследовать значения указанных параметров от родительского блока */
}

html,
body {
  height: 100%;
  line-height: 1;
  background: #fafafa;
  font-size: 14px;
  color: #252b42;
  font-weight: 500;
  font-family: Montserrat;
}

/* ---------------------------------------------------------------------------- */
.wrapper {
  min-height: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  /* Применения свойства флекс контейнера (display: flex) и его параметра выравнивания в колонку (flex-direction: column) "приклеивает" футер внизу страницы 
  Добавляется параметр "min-height" со значением 100%, что позволяет контенту занимать всю площадь родительского блока (в данном случае, применяется ко всем трём родительским блокам: html, body, wrapper);
  */
}

.container {
  max-width: 1046px;
  padding: 0px 15px;
  margin: 0px auto;
  box-sizing: content-box;
}

.ibg {
  position: relative;
}

.ibg img {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  object-fit: cover;
  /* Свойство object-fit определяет, как содержимое заменяемого элемента, такого как <img> или <video>, должно заполнять контейнер относительно его высоты и ширины. Значение 'cover' означает, что смещаемый контент меняет свой размер таким образом, чтобы сохранять свои пропорции при заполнении блока: окончательный размер контента будет определён как "покрытие" блока, ограничиваясь его шириной и высотой. */
}

/*# sourceMappingURL=style.css.map */
/* --ШАПКА------------------------------------- */
.header {
  position: absolute;
  width: 100%;
  left: 0;
  top: 0;
  /* прибиваем к левому верхнему краю контейнера */
  z-index: 50;
  /* Хорошая практика применять к параметру "z-index" значение, кратное 10 */
}
.header__container {
  display: flex;
  min-height: 104px;
  align-items: center;
}

@media (max-width: 479px) {
  .header__container {
    min-height: 70px;
    /* Медиа запрос на изменение размера шапки (блок header__container) при уменьшении ширины экрана до 479px (параметр 'max-width') и установления минимально высоты в 70px (параметр 'min-height') - для телефонов с маленьким экраном. */
  }
}

.header__logo {
  font-size: 24px;
  font-weight: 700;
  color: inherit;
  /* Задаём цвету параметр inherit чтобы наследовались свойства, обозначенные  вверху для body (ссылки по умолчанию не наследуют свойства родительских блоков*/
}

.header__menu {
  margin: 0px 0px 0px 133px;
}

@media (max-width: 992px) {
  .header__menu {
    margin: 0px 0px 0px 80px;
    /* Медиа запрос на уменьшение внешнего отступа блока (margin) до 80px при достижении ширины 992px (параметр max-width) */
  }
}

@media (max-width: 767px) {
  .header__menu {
    margin: 0px 0px 0px 40px;
    /* Медиа запрос на уменьшение внешнего отступа блока (margin) до 40px при достижении ширины 767px (параметр max-width) - для планшетного разрешения*/
  }
}

@media (max-width: 479px) {
  .header__menu {
    margin: 0px 0px 0px 20px;
    /* Медиа запрос на уменьшение внешнего отступа блока (margin) до 20px при достижении ширины 479px (параметр max-width) - телефонов с маленьким экраном*/
  }
}

.menu {
  padding: 5px 0;
}

.menu__list {
  flex-wrap: wrap;
  /* Параметр нужен для переноса элементов списка на следующую строку при меньшем разрешении экрана (на телефонах) и избежания выхода списка за пределы экрана*/
  display: flex;
}

.menu__item {
}

.menu__item:not(:last-child) {
  margin: 0px 21px 0px 0px;
  /* Здесь мы применяем внешний отступ для всех элементов списка кроме последнего (параметр :not(:last-child)) во избежание провисающих отступов, "съедающих" лишнее пространство */
}

.menu__link {
  color: #737373;
  font-weight: 600;
  line-height: calc(24 / 14 * 100%);
  /* Функция 'calc' позволяет совершить математические операции внутри css, и в данном случае рассчитывает оптимальную высоту строки в пропорциях к остальному шрифту. Пояснение: изначально в макете параметр 'line-height' имел значение 24px. Делим на размер шрифта, указанного для всего блока body вначале css (14px) и умножаем на 100%, что приблизительно равняется 171%. */
}

@media (max-width: 479px) {
  .menu__link {
    font-size: 18px;
    /* Медиа запрос на уменьшение увеличение шрифта (font-size до 18px при достижении ширины 479px (параметр max-width) - телефонов с маленьким экраном. При этом автоматически подтягивается высота строки (line-height), т.к. значение рассчитывается в процентах */
  }
}

/* --PAGE------------------------------------- */
.page {
  flex: 1 1 auto;
  /* Даётся разрешение\запрет на следующие параметры флекса: "flex-grow" (способность дочернего блока занять всю доступную\свободную площадь родительского контейнера (не занятую другими элементами)); "flex-shrink" (способность дочернего блока сжиматься в рамках родительского контейнера); "flex-basis" (задаёт базовый размер флекс элемента по основной оси. Это свойство определяет размер контент-бокса, если не задано иначе через box-sizing). */
}

.page__mainblock {
}

.page__services {
  position: relative;
  z-index: 2;
  margin: -111px 0px 0px 0px;
  /* Ставим отрицательный внешний отступ, добавляем относительное позиционирование и индекс наложения 2, чтобы блок сервисов частично "налез" над первой страницей. 
  В этом случае нельзя применить position: absolute и отступы, т.к. в этом случае все остальные блоки не подтянутся за текущим и образуется пробел.
  */
}

@media (max-width: 669px) {
  .page__services {
    margin: 10px 0px 0px 0px;
    /* ! Собственный фикс: выставляем положительный отступ для перемещения блока на следующую страницу при уменьшении ширины экрана*/
    display: flex;
    /* ! Собственный фикс: выравнивание колонок по центру при уменьшении ширины экрана */
  }
}

.page__achievements {
}

.page__practice {
}

.page__whoweare {
}

.page__clients:not(:last-child) {
  margin: 0px 0px 10px 0px;
  /* Создаём отступ в 10px от элемента
  Применяем not:last-child на случай, если данный элемент будет последним на сайте, чтобы не было провисающих отступов
  */
}

.page__subscribe {
}
/* --HEADER-BLOCK------------------------------------- */

.header-block {
  text-align: center;
  letter-spacing: 0.2px;
}

.header__block_title {
  font-size: 40px;
  font-weight: 700;
  line-height: calc(57 / 40 * 100%);
  /* ! В очередной раз вручную изменил конечную величину (проценты) на мат-формулу для большей гибкости вёрстки (при необходимости изменить параметры, например) */
}

.header__block_title:not(:last-child) {
  margin: 0px 0px 10px 0px;
}

.header__block_sub-title {
  color: #737373;
  line-height: calc(57 / 40 * 100%);
}

@media (max-width: 992px) {
  .header__block_title {
    font-size: 35px;
    /* Уменьшаем шрифт хедера при уменьшении разрешения экрана */
  }
}

@media (max-width: 767px) {
  .header__block_title {
    font-size: 30px;
    /* Уменьшаем шрифт хедера при уменьшении разрешения экрана */
  }
}

/* --ПОДВАЛ------------------------------------- */
.footer {
}

/* --MAIN-BLOCK------------------------------------- */

.main-block {
  position: relative;
}

.mainblock__container {
}

.main-block__body {
  padding: 184px 0px 191px 0px;
  position: relative;
  z-index: 2;
  max-width: 400px;
}

@media (max-width: 992px) {
  .main-block__body {
    padding: 120px 0px 191px 0px;
    /* Создание медиа запроса на уменьшения внутреннего отступа контейнера с основным контентом при уменьшении ширины экрана до 992px (для большей компактности текста) */
  }
}

@media (max-width: 479px) {
  .main-block__body {
    padding: 115px 0px 10px 0px;
  }
}

.main-block__body > *:not(:last-child) {
  /* Комбинация "> *" это обращение ко всем объектам первого уровня. Это значит, что в данном блоке кода свойства будут применяться только к первым блокам родительского контейнера, не затрагивая их подблоки. В данном случае, это main-block__title, main-block__text и main-block__buttons */
  margin: 0px 0px 35px 0px;
}

.main-block__title {
  font-weight: 800;
  font-size: 58px;
  line-height: calc(80 / 58 * 100%);
  /* Здесь применяется та же логика, что и в строке 154 - вычисление оптимального размера высоты строки, путём деления значения в макете на текущий размер шрифта */
  letter-spacing: 0.2px;
  /* Применяется параметр дополнительного расстояние между буквами */
}

@media (max-width: 479px) {
  .main-block__title {
    font-size: 42px;
    /* Медиа запрос на уменьшение величины шрифта заголовка при уменьшении ширины экрана до 479px (для большей компактности текста) */
  }
}

.main-block__text {
  color: #737373;
  font-size: 20px;
  line-height: calc(30 / 20 * 100%);
  /* См выше */
}

@media (max-width: 479px) {
  .main-block__text {
    color: #585757;
  }
}

.main-block__buttons {
  display: flex;
  /* Выстраивание флекс-контейнеров в линию по горизонтали, пример: https://i.stack.imgur.com/mns2H.jpg */
  flex-wrap: wrap;
  /* Разрешение флекс-контейнеру переносить дочерние элементы на новую строку при уменьшении разрешения экрана  */
  margin: -10px 0px;
  /* Уменьшаем отступ сверху и снизу от предыдущего элемент в контейнере на 10px */
}

@media (max-width: 992px) {
  .main-block__buttons {
    margin: 15px 0px;
    /* ! Добавил от себя медиа запрос для большего отступа между кнопками и описанием при уменьшении ширины экрана до планшетных размеров */
  }
}

.main-block__button {
  border-radius: 37px;
  display: flex;
  min-height: 48px;
  justify-content: center;
  align-items: center;
  letter-spacing: 0.2px;
  font-weight: 700;
  line-height: 150%;
  text-align: center;
  /* Выравнивание текста по горизонтльной оси, т.е. слева, справа, по центру, равномерно */
  padding: 5px 36px;
  margin: 10px 0px;
  /* Компенсируем уменьшение отступа сверху и снизу от предыдущего элемента на те же 10px для создания отступа для нижней кнопки при перенесении её на другую строку (уменьшение ширины экрана)*/
}

@media (max-width: 479px) {
  .main-block__button {
    flex: 1 1 100%;
    /* См. стр. 171 */
  }
}

@media (min-width: 479px) {
  .main-block__button:not(:last-child) {
    margin-right: 10px;
    /* Отступ вправо на 10px доступно только для ширины экрана > 479px (aka 'Mobile first') */
  }
}

.orange {
  background: #ff7b47;
  color: #fff;
}

.border {
  color: #0d5c63;
  border: 1px solid;
}

.main-block__image {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}

@media (max-width: 1300px) {
  .main-block__image img {
    object-position: right;
    /* Создание медиа запроса для выравнивание картинки по правой стороне при изменении разрешении <= 1300px (для лучшего позиционирования фона) */
  }
}

@media (max-width: 992px) {
  .main-block__image {
    opacity: 0.5;
    /* Создание медиа запроса для увеличении прозрачности заднего фона при изменении разрешении <= 992px (для лучшей читтаемости заголовка) */
  }
}
/* ------------------------------------------------------------------------ */

.services {
}
.page__services-container {
  margin: 0 auto;
  display: flex;
  align-items: center;
  max-width: 1046px;
  justify-content: space-between;
}

.services__body {
}

@media (min-width: 670px) {
  .services__body {
    display: flex;
    flex-wrap: wrap;
    margin: 0px -15px;
    /* Ставим к оболочке отрицательный внешний отступ, чтобы компенсировать аналогичный отступ в дочернем контейнере */
  }
}

@media (min-width: 670px) {
  .services__body {
    padding: 0px 15px;
  }
}

.services__column {
  padding: 0px 15px;
  flex: 0 1 calc(1 / 3 * 100%);
  /* Значение 33.333% для параметра flex-basis нужно, чтобы колонка занимала примерно треть всего контейнера (всего в контейнере 3 колонки, 1 колонка / 3 * 100% * = 33,(3)%) */
}

@media (max-width: 992px) {
  .services__column {
    flex: 0 1 50%;
    /* Медиа запрос при уменьшении ширины до 992px, разрешающий флекс контейнеру сжиматься и задающий базовый размер контейнера в половину от его изначальной величины (flex-basis: 50%). Как итог, две первые колонки будут занимать целую строку */
    text-align: center;
    /* ! Добавил от себя центрирование текста при уменьшении размеров экрана до 992px*/
  }
  .services__column:not(:last-child) {
    margin: 0px 0px 30px 0px;
  }
  .services__column:last-child {
    flex: 1 1 100%;
    /* Чтобы последняя колонка могла занимать всю строку под первыми двумя, разрешаем контейнеру расти (flex-grow 1), и даём размер в полную величину родительского конейнера (flex-basis: 100%) */
  }
}

.services__item {
  height: 100%;
  /* В данном случае, мы устанавливаем для элемента 100%ную высоту от родительского блока, чтобы все три колонки были одинакового размера */
  box-shadow: 0px 13px 19px rgba(0, 0, 0, 0.07);
  /* Параметр box-shadow добавляет фоновую тень к объекту\блоку\картинке, имеющий два значения - толщина (задаётся как и отступ, по часовой стрелке) и цвет тени*/
  background-color: #fff;
  padding: 35px;
}

@media (max-width: 479px) {
  .services__item {
    padding: 25px;
  }
}

.item-service {
}

.item-service > *:not(:last-child) {
  margin: 0px 0px 10px 0px;
}

.item-service__green {
  background-color: #0d5c63;
}

.white {
  color: #fff;
}

.item-service__icon {
}

.item-service__title {
  font-weight: 700;
  letter-spacing: 0.1px;
  font-size: 24px;
  line-height: calc(32 / 24 * 100%);
}
.item-service__text:not(:last-child) {
  color: #737373;
}
.item-service__text {
  line-height: calc(20 / 14 * 100%);
}
/* ----------------------------------------------------- */

.achievements {
  padding: 80px 0;
}

@media (max-width: 992px) {
  .achievements {
    padding: 50px 0;
    /* Уменьшаем отступ при уменьшении ширины экрана*/
  }
}

@media (max-width: 767px) {
  .achievements {
    padding: 40px 0;
    /* см. выше*/
  }
}

.achievements__container {
}

.achievements__header {
  margin: 0px 0px 50px 0px;
}

@media (max-width: 767px) {
  .achievements__header {
    margin: 0px 0px 25px 0px;
    /* Уменьшаем отступ хедера при уменьшении ширины экрана*/
  }
}

.achievements__body {
  display: flex;
  flex-wrap: wrap;
  /* Даём разрешение контейнеру переносить элементы на новую строку при изменении разрешения экрана */
  margin: 0px -15px -30px;
}

.achievements__column {
  padding: 0px 15px;
  margin: 0px 0px 30px 0px;
  flex: 0 1 25%;
}

@media (max-width: 1075px) {
  /* ! Увеличил вручную с 1020px (как в видео) до 1075px, т.к. в данном разрешении колонки уже становятся разными по размеру */
  .achievements__column {
    flex: 0 1 50%;
    /* Даём медиазапрос на увеличение контейнеров колонок до 50% размера от выданной области контейнера (за минусом отступов) */
  }
}

@media (max-width: 560px) {
  .achievements__column {
    flex: 0 1 100%;
  }
}

.achievements__item {
  background-color: #fff;
  padding: 30px 40px;
  font-weight: 700;
  text-align: center;
}

.achievements__item > *:not(:last-child) {
  margin: 0px 0px 10px 0px;
}

.achievements__icon {
  height: 48px;
  /* Выравниваем высоту для всех иконок */
  display: flex;
  align-items: flex-end;
  /* "Прибиваем" невысокие иконки к низу флекс-контейнера (т.к. ось вертикальная, конец контейнера находится снизу */
  justify-content: center;
  /* Ставим иконки по середине контейнера */
}

.achievements__value {
  font-size: 40px;
  line-height: calc(57 / 40 * 100%);
}

.achievements__text {
  /* letter-spacing: 0.1px; */
  /* ! В видео верстальшик таким образом пытался выстроить текст в строку, но в моём случае это не сработало. см ниже (параметр закоментирован)*/
  color: #737373;
  font-size: 15px;
  /* ! В макете Figma размер шрифта 16px, но текст идёт в строку. Чтобы добиться строчного текста, вручную уменьшил шрифт на 1px  */
  line-height: calc(24 / 15 * 100%);
  /* ! В вычислении величины строки введено изменённое значение размера шрифта */
}
/* ----------------------------------------------------- */
.practice {
  padding: 125px 0px 80px 0px;
}

@media (max-width: 993px) {
  .practice {
    padding: 40px 0px 80px 0px;
    /* Работаем с отступами при уменьшении ширины экрана*/
  }
}

@media (max-width: 767px) {
  .practice {
    padding: 0px 0px 40px 0px;
    /*  см. выше */
  }
}

.practice__container {
}

.practice__header {
  margin: 0px 0px 45px 0px;
}

@media (max-width: 993px) {
  .practice__header {
    padding: 0px 0px 25px 0px;
  }
}

.practice__body {
  margin: 0px -20px -30px;
  display: flex;
  flex-wrap: wrap;
}

.practice__column {
  padding: 0px 20px;
  margin: 0px 0px 30px 0px;
  flex: 0 1 25%;
}

@media (max-width: 1040px) {
  .practice__column {
    flex: 0 1 50%;
    /* Как и ранее, увеличиваем размер карточки до 50% с уменьшением экрана */
  }
}

@media (max-width: 630px) {
  .practice__column {
    flex: 0 1 100%;
    /* То же самое, но теперь уже карточка занимает всю строку при меньшем разрешении (100%) */
  }
}

.practice__item {
}

.item-practice {
  background-color: #fff;
  display: flex;
  flex-direction: column;
  /* Делаем контейнер флексом, разворачиваем ось на вертикальную */
  height: 100%;
  /* Даём контенту возможность занимать всё пустое пространство */
}

.item-practice__content {
  padding: 30px;
  flex: 1 1 auto;
  /* Разрешаем контенту увеличиваться в размерах */
}

.item-practice__link {
  color: inherit;
  display: inline-block;
  /*  ВАЖНО: для строчной ссылки не сработает выставленный ниже внешний отступ, поэтому необходимо применить параметр display со значением inline-block*/
}

.item-practice__link:not(:last-child) {
  margin: 0px 0px 15px 0px;
  /* Вышеупомянутый отступ, применяемый ко всем элементам в блоке, кроме последнего */
}

.item-practice__link:hover {
  text-decoration: underline;
  color: #ff7b47;
  /* ! Добавил от себя изменения цвет при наведении курсора */
}

.item-practice__title {
  letter-spacing: 0.1px;
  font-size: 14px;
  /* ! Аналогично предыдущему блоку с текстом, уменьшил шрифт, в данном случае до 14px, чтобы весь текст уместился в 1 строку  */
  line-height: calc(24 / 14 * 100%);
  /* ! По этой же причине при вычислении высоты строки, задал значение 14 (текущий размер шрифта) вместо 16 (по видео) */
  font-weight: 700;
}

.item-practice__text {
  color: #737373;
  line-height: calc(20 / 14 * 100%);
}

.item-practice__image {
  display: block;
  /* Делается для ссылки */
  padding: 0px 0px 60% 0px;
  /* Пояснение про проценты: берём высоту изображения (138px) и делим на его ширину (230px) и умножаем на 100%, итого 138 / 230 * 100% = 60%  */
}

/* ------------------------------------------ */

.whoweare {
  background: #ffffff;
  padding: 80px 0px 130px 0px;
}

.whoweare__container {
}

.whoweare__header {
  margin: 0px 0px 100px 0px;
}

.whoweare__body {
  display: flex;
  align-items: flex-start;
  /* "Прижимаем" элементы контейнера к началу (верху) контейнера при уменьшении разрешения */
}

.whoweare__video {
  flex: 0 0 calc(600 / 1046 * 100%);
  /* !Задаём размер флекса с помощью математической формулы 'calc' вместо выставления 57%. Здесь 600 - размер флекс-элемента из макета, 1046 - размер флекс-контейнера. Так выходит по причине того, что блок .whoweare_video не имеет собственного родительского флекс-контейнера, и является и элементом, и флекс-контейнером одновременно. */
  position: relative;
  padding: 0px 0px calc(442 / 1046 * 100%) 0px;
  /* !Задаём размерозадающий внешний отступ через такую же формулу */
}

.whoweare__video iframe {
  /* Обращаемся к тегу iframe, с помощью которого вставлено видео */
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  object-fit: cover;
}

.whoweare__content {
  flex: 1 1 auto;
  padding: 20px 0px 0px 121px;
}

.whoweare__title {
  font-weight: 800;
  font-size: 40px;
  line-height: calc(57 / 40 * 100%);
  /* ! Делим высоту строки из макета на размер шрифта */
  letter-spacing: 0.2px;
}

.whoweare__title:not(:last-child) {
  margin: 0px 0px 10px 0px;
  /* Делаем отступ от заголовка */
  /* ? Почему применяется именно :not(:last-child)? У нас же и так вложен один элемент. */
}

.whoweare__text {
  color: #737373;
  font-size: 14px;
  line-height: calc(20 / 14 * 100%);
  /* ! Или те же 142(.8)% */
}

.whoweare__top:not(:last-child) {
  margin: 0px 0px 50px 0px;
}

.whoweare__items {
}

.whoweare__item {
}

.whoweare__item:not(:last-child) {
  margin: 0px 0px 30px 0px;
  /* В колонке нам нужен отступ только между двумя блоками, поэтому применяем not:last-child чтобы не было "провисания" из-за пустого отступа после второго (последнего) блока */
}

.item-whoweare {
  display: flex;
}

.item-whoweare__icon {
  flex: 0 0 32px;
}

.item-whoweare__body {
  flex: 1 1 auto;
  padding: 0px 0px 0px 20px;
}

.item-whoweare__title {
  font-weight: 700;
  font-size: 16px;
  line-height: calc(24 / 16 * 100%);
  /* ! См. выше */
}

.item-whoweare__title:not(:last-child) {
  margin: 0px 0px 5px 0px;
}

.item-whoweare__text {
  color: #737373;
  white-space: nowrap;
  /* Параметр "white-space" контролирует поведение пробельных символов внутри элемента. При значении "nowrap" пробелы не переносятся на новую строку. */
  line-height: calc(20 / 14 * 100%);
  width: 225px;
  /* Фиксируем ширину строки, чтобы сработал параметр "text-overflow" */
  overflow: hidden;
  /* Свойство "overflow" определяет, нужно ли для переполненного блочного элемента обрезать контент, предоставить полосы прокрутки или просто отобразить (в последнем случае, контент будет вылазить за рамки блока).
  При значении "hidden" контент обрезается без прокрутки.*/
  text-overflow: ellipsis;
  /* При обрезании контента можно применить два значения: clip (текст обрезается по размеру области) и ellipsis (текст обрезается и добавляется многоточие в конце строки). */
}

@media (max-width: 1080px) {
  .whoweare__content {
    padding: 0px 0px 0px 50px;
    /* Убираем и уменьшаем отступы при уменьшении ширины экрана */
  }
}

@media (max-width: 950px) {
  /* Создаём единый медиазапрос для нескольких элементов при уменьшении ширины экрана до 950px (Принцип Keep It Simple Stupid)*/
  .whoweare {
    padding: 50px 0px 50px 0px;
    /* Уменьшаем внешний отступ для всего блока */
  }
  .whoweare__body {
    flex-direction: column-reverse;
    /* Устанавливаем вертикальную ось для элементов контейнера, и меняем их порядок (сперва текст, затем видео) */
    /* ВАЖНО! При установлении вертикальной оси и обратного порядка контента блок с видео пропадает. Это фиксится с помощью следующей строки. */
    align-items: stretch;
    /* Растягиваем контент по всей длине контейнера, и таким образом отображается съехавший блок с видео */
  }
  .whoweare__title {
    font-size: 24px;
    /* Уменьшаем шрифт заголовка */
  }
  .whoweare__content {
    padding: 0px 0px 0px 50px;
    /* Уменьшаем внутренний отступ для контента */
  }
  .whoweare__video {
    padding: 0px 0px calc(315 / 560 * 100%) 0px;
    /* !При изменении пропорций видео брались значения из самого видео при его встраивании */
  }
  .whoweare__video:not(:last-child) {
    margin: 50px 0px 0px 0px;
    /* ? В блоке .whoweare__video всего лишь один элемент - сам блок с видео. Как так получается, что работает свойство not:last-child и появляется верхний отступ? */
  }
  .whoweare__header {
    margin: 0px 0px 30px 0px;
    /* Уменьшаем внешний отступ для хедера */
  }
}

@media (max-width: 767px) {
  .whoweare {
    padding: 20px 0px 50px 0px;
  }
  .whoweare__top:not(:last-child) {
    margin: 0px 0px 30px 0px;
  }
  .whoweare__video:not(:last-child) {
    margin: 30px 0px 0px 0px;
  }
}
/* ---------------------------------- */
.clients {
  padding: 50px 0;
}

@media (max-width: 767px) {
  .clients {
    padding: 30px 0;
  }
}

.clients__container {
}

.clients__items {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
  /* Ставим контент в центр по горизонтальной линии для равномерного распределения при уменьшении ширины экрана*/
}

.clients__item {
  padding: 8px 15px;
  flex: 0 1 16.6667%;
  /* Т.к. вкладок клиентов всего 6 штук, необходимо чтобы каждая из них занимала равную часть страницы. Для этого, делим 100% от ширины контейнера на 6 и получаем ~16.6667% */
  text-align: center;
  min-width: 140px;
  /* Устанавливаем жёсткие рамки минимальной ширины*/
}

.clients__item img {
  max-width: 100%;
  /* Делается на случай появления большой картинки в блоке, чтобы картинка не обрезалась */
}
/* -------------------------------------- */

.subscribe {
}

.subscribe__container {
}

.subscribe__body {
  margin: 0px 30px;
  display: flex;
  justify-content: space-between;
  padding: 30px 50px;
  align-items: center;
  background: #17213c;
  border-radius: 2px;
}

.subscribe__title {
  flex: 0 1 50%;
  /* Даём разрешение флексу на уменьшение + задаём размер в 50% от родительского контейнера */
  color: #ffffff;
  /* ? Есть ли разница между #fff и #ffffff? */
  font-size: 24px;
  line-height: calc(32 / 24 * 100%);
  /* ! Опять берём данные с макета: размер шрифта (32px) делим на высоту строки (24px) и смотрим, сколько это в процентах (~133%). Ставим формулу вручную вместо процентов для более удобной проработки */
  font-weight: 700;
  letter-spacing: 0.1px;
}

.subscribe__form {
  max-width: 266px;
  /* Здесь пришлось ограничить максимальную ширину формы чтобы было больше похоже на макет  */
  margin: 0px 20px 0px 0px;
  /* ! Так как форма практически вплотную подходила к границе контейнера, добавил вручную внешнего отступа */
  display: flex;
  align-items: center;
}

.subscribe__input {
  flex: 1 1 auto;
  min-height: 58px;
  padding: 0px 20px;
  background: #f9f9f9;
  color: #737373;
  /* Цвет текста по умолчанию (Your Email) */
  border: 1px solid #e6e6e6;
  border-right: 0;
  border-radius: 5px 0px 0px 5px;
  /* В данном случае ставится радиус только по левым краям кнопки, верхней и нижней. Логика часовой стрелки соблюдается как и в других подобных значениях. */
}

.subscribe__input:focus {
  color: #000;
  /* Добавляем чёрный цвет при введении текста в форму  */
}

.subscribe__button {
  background: #ff7b47;
  border: 1px solid #e6e6e6;
  border-radius: 0px 5px 5px 0px;
  /* Здесь ситуация, обратная вышеописанной: радиус только для правой части кнопки */
  display: flex;
  min-height: 58px;
  justify-content: center;
  align-items: center;
  text-align: center;
  color: #fff;
  padding: 0px 22px;
}
